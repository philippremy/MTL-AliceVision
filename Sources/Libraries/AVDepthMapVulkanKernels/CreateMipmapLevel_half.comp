#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

#include "definitions.comp"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// The input image (all mip levels)
layout(set = 0, binding = 0) uniform sampler2D in_image;

// The out image mip level as indicated in the push constants
layout(rgba16f, set = 0, binding = 1) uniform writeonly image2D out_mipmappedArrayLevel;

// The gaussian array offset array
layout(set = 0, binding = 2, scalar) uniform readonly GaussianArrayOffset {
    int offsets[MAX_CONSTANT_GAUSS_SCALES];
} d_gaussianArrayOffset;

// The gaussian array
layout(set = 0, binding = 3, scalar) uniform readonly GaussianArray {
    float gaussian[MAX_CONSTANT_GAUSS_MEM_SIZE];
} d_gaussianArray;

// The shader arguments
layout(push_constant, scalar) uniform PushConstants {
    int radius;
    uint out_mipLevel;
} pushConstants;

// Lookup gaussian blur value
float getGauss(int scale, int idx) {
    return d_gaussianArray.gaussian[d_gaussianArrayOffset.offsets[scale] + idx];
}

void main() {

    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;

    // Get downscaled image width and height
    ivec2 outImageSize = imageSize(out_mipmappedArrayLevel);

    if(x >= outImageSize.x || y >= outImageSize.y)
        return;

    const float16_t px = float16_t(1.f) / float16_t(outImageSize.x);
    const float16_t py = float16_t(1.f) / float16_t(outImageSize.y);

    f16vec4 sumColor = f16vec4(0.0f, 0.0f, 0.0f, 0.0f);
    float16_t sumFactor = float16_t(0.0f);

    for(int i = -pushConstants.radius; i <= pushConstants.radius; i++)
    {
        for(int j = -pushConstants.radius; j <= pushConstants.radius; j++)
        {
            // domain factor
            const float factor = getGauss(1, i + pushConstants.radius) * getGauss(1, j + pushConstants.radius);

            // normalized coordinates
            vec2 uv = vec2((float(x + j) + 0.5) * float(px), (float(y + i) + 0.5) * float(py));

            // current pixel color
            const f16vec4 color = f16vec4(textureLod(in_image, uv, float(pushConstants.out_mipLevel - 1)));

            // sum color
            sumColor = sumColor + color * float16_t(factor);

            // sum factor
            sumFactor += float16_t(factor);
        }
    }

    const f16vec4 color = sumColor / sumFactor;

    imageStore(out_mipmappedArrayLevel, ivec2(x, y), color);

}
