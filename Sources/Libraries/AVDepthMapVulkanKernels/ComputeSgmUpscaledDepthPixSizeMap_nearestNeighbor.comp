#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require

#include "definitions.comp"
#include "DeviceCameraParams.comp"
#include "ROI.comp"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// The upscaled output depth pixel size map
layout(rg32f, set = 0, binding = 0) uniform image2D out_upscaledDepthPixSizeMap_d;

// The input similiarity depth thickness map
layout(rg32f, set = 0, binding = 1) uniform readonly image2D in_sgmDepthThicknessMap_d;

// The input image
layout(set = 0, binding = 2) uniform sampler2D rcMipmapImage_tex;

// Device Camera Params Array
layout(set = 0, binding = 3, scalar) uniform DeviceCameraParamsConstant {
    DeviceCameraParams cameraParams[ALICEVISION_DEVICE_MAX_CONSTANT_CAMERA_PARAM_SETS];
} constantCameraParametersArray_d;

// The shader arguments
layout(push_constant, scalar) uniform PushConstants {
    int rcDeviceCameraParamsId;
    uint rcLevelWidth;
    uint rcLevelHeight;
    float rcMipmapLevel;
    int stepXY;
    int halfNbDepths;
    float ratio;
    ROI roi;
} pushConstants;

void main() {

    uint roiX = gl_GlobalInvocationID.x;
    uint roiY = gl_GlobalInvocationID.y;

    if(roiX >= ROI_width(pushConstants.roi) || roiY >= ROI_height(pushConstants.roi))
        return;

    // corresponding image coordinates
    const uint x = (pushConstants.roi.x.begin + roiX) * uint(pushConstants.stepXY);
    const uint y = (pushConstants.roi.y.begin + roiY) * uint(pushConstants.stepXY);

    // corresponding output upscaled depth/pixSize map
    vec4 out_depthPixSize = imageLoad(out_upscaledDepthPixSizeMap_d, ivec2(roiX, roiY));

    // filter masked pixels with alpha
    if(textureLod(rcMipmapImage_tex, ivec2((float(x) + 0.5f) / float(pushConstants.rcLevelWidth), (float(y) + 0.5f) / float(pushConstants.rcLevelHeight)), pushConstants.rcMipmapLevel).w < 0.9f)
    {
        imageStore(out_upscaledDepthPixSizeMap_d, ivec2(roiX, roiY), vec4(-2.f, 0.f, out_depthPixSize.z, out_depthPixSize.w));
        return;
    }

    // find adjacent pixels
    const float oy = (float(roiY) - 0.5f) * pushConstants.ratio;
    const float ox = (float(roiX) - 0.5f) * pushConstants.ratio;

    int xp = int(floor(ox + 0.5));
    int yp = int(floor(oy + 0.5));

    xp = min(xp, int(ROI_width(pushConstants.roi)  * pushConstants.ratio) - 1);
    yp = min(yp, int(ROI_height(pushConstants.roi) * pushConstants.ratio) - 1);

    // find corresponding depth/thickness
    vec4 out_depthThickness = imageLoad(in_sgmDepthThicknessMap_d, ivec2(xp, yp));

    // compute pixSize from depth thickness
    const float out_pixSize = out_depthThickness.y / pushConstants.halfNbDepths;

    // write output depth/pixSize
    out_depthPixSize.x = out_depthThickness.x;
    out_depthPixSize.y = out_pixSize;

    imageStore(out_upscaledDepthPixSizeMap_d, ivec2(roiX, roiY), out_depthPixSize);

}