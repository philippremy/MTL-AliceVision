#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

#include "definitions.comp"

layout(local_size_x = 32, local_size_y = 2, local_size_z = 1) in;

// The input image (full sized)
layout(set = 0, binding = 0) uniform sampler2D in_img_tex;

// The downscaled output image
layout(rgba16f, set = 0, binding = 1) uniform writeonly image2D out_downscaledImg_d;

// The gaussian array offset array
layout(set = 0, binding = 2, scalar) uniform readonly GaussianArrayOffset {
    int offsets[MAX_CONSTANT_GAUSS_SCALES];
} d_gaussianArrayOffset;

// The gaussian array
layout(set = 0, binding = 3, scalar) uniform readonly GaussianArray {
    float gaussian[MAX_CONSTANT_GAUSS_MEM_SIZE];
} d_gaussianArray;

// The shader arguments
layout(push_constant, scalar) uniform PushConstants {
    int downscale;
    int gaussRadius;
} pushConstants;

// Lookup gaussian blur value
float getGauss(int scale, int idx) {
    return d_gaussianArray.gaussian[d_gaussianArrayOffset.offsets[scale] + idx];
}

void main() {

    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;

    // Get downscaled image width and height
    ivec2 outImageSize = imageSize(out_downscaledImg_d);

    if((x < outImageSize.x) && (y < outImageSize.y)) {

        const float s = float(pushConstants.downscale) * 0.5;

        f16vec4 accPix = f16vec4(0.0, 0.0, 0.0, 0.0);
        float16_t sumFactor = float16_t(0.0);

        for(int i = -pushConstants.gaussRadius; i <= pushConstants.gaussRadius; i++)
        {
            for(int j = -pushConstants.gaussRadius; j <= pushConstants.gaussRadius; j++)
            {
                vec2 pixelCoord = vec2(float(x * pushConstants.downscale + j) + s,
                float(y * pushConstants.downscale + i) + s);

                ivec2 texel = ivec2(pixelCoord);
                f16vec4 curPix = f16vec4(texelFetch(in_img_tex, texel, 0));

                const float factor = getGauss(pushConstants.downscale - 1, i + pushConstants.gaussRadius) *
                getGauss(pushConstants.downscale - 1, j + pushConstants.gaussRadius); // domain factor

                accPix = accPix + curPix * float16_t(factor);
                sumFactor += float16_t(factor);
            }
        }

        f16vec4 outPix = f16vec4(0.0, 0.0, 0.0, 0.0);
        outPix = accPix / sumFactor;

        imageStore(out_downscaledImg_d, ivec2(x, y), outPix);

    }

}