#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require

#include "ROI.comp"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// The input sgm depth pixel size map
layout(rg32f, set = 0, binding = 0) uniform image2D out_refineDepthSimMap_d;

// The input normal map
layout(rg32f, set = 0, binding = 1) uniform readonly image2D in_sgmDepthPixSizeMap_d;

// The input/output similarity volume
layout(r32f, set = 0, binding = 3) uniform image3D in_volSim_d;

// The shader arguments
layout(push_constant, scalar) uniform PushConstants {
    int volDimZ;
    int samplesPerPixSize;
    int halfNbSamples;
    int halfNbDepths;
    float twoTimesSigmaPowerTwo;
    ROI roi;
} pushConstants;

void main() {

    uint vx = gl_GlobalInvocationID.x;
    uint vy = gl_GlobalInvocationID.y;

    if(vx >= ROI_width(pushConstants.roi) || vy >= ROI_height(pushConstants.roi)) // no need to check roiZ
        return;

    // corresponding input sgm depth/pixSize (middle depth)
    const vec2 in_sgmDepthPixSize = imageLoad(in_sgmDepthPixSizeMap_d, ivec2(vx, vy)).xy;

    // corresponding output depth/sim pointer
    vec4 out_bestDepthSimPtr = imageLoad(out_refineDepthSimMap_d, ivec2(vx, vy));

    // sgm depth (middle depth) invalid or masked
    if(in_sgmDepthPixSize.x <= 0.0f)
    {
        out_bestDepthSimPtr.x = in_sgmDepthPixSize.x;  // -1 (invalid) or -2 (masked)
        out_bestDepthSimPtr.y = 1.0f;                  // similarity between (-1, +1)
        imageStore(out_refineDepthSimMap_d, ivec2(vx, vy), out_bestDepthSimPtr);
        return;
    }

    // find best z sample per pixel
    float bestSampleSim = 0.f;      // all sample sim <= 0.f
    int bestSampleOffsetIndex = 0;  // default is middle depth (SGM)

    // sliding gaussian window
    for(int samp = -pushConstants.halfNbSamples; samp <= pushConstants.halfNbSamples; ++samp)
    {
        float sampleSim = 0.f;

        for(int vz = 0; vz < pushConstants.volDimZ; ++vz)
        {
            const int rz = (vz - pushConstants.halfNbDepths);    // relative depth index offset
            const int zs = rz * pushConstants.samplesPerPixSize; // relative sample offset

            // get the inverted similarity sum value
            // best value is the HIGHEST
            // worst value is 0
            // NOTE: Always returns a vec4, only use x as only 1 value is stored!
            const float invSimSum = imageLoad(in_volSim_d, ivec3(vx, vy, vz)).x;

            // reverse the inverted similarity sum value
            // best value is the LOWEST
            // worst value is 0
            const float simSum = -invSimSum;

            // apply gaussian
            // see: https://www.desmos.com/calculator/ribalnoawq
            sampleSim += simSum * exp(-((zs - samp) * (zs - samp)) / pushConstants.twoTimesSigmaPowerTwo);
        }

        if(sampleSim < bestSampleSim)
        {
            bestSampleOffsetIndex = samp;
            bestSampleSim = sampleSim;
        }
    }

    // compute sample size
    const float sampleSize = in_sgmDepthPixSize.y / pushConstants.samplesPerPixSize; // input sgm pixSize / samplesPerPixSize

    // compute sample size offset from z center
    const float sampleSizeOffset = bestSampleOffsetIndex * sampleSize;

    // compute best depth
    // input sgm depth (middle depth) + sample size offset from z center
    const float bestDepth = in_sgmDepthPixSize.x + sampleSizeOffset;

    // write output best depth/sim
    out_bestDepthSimPtr.x = bestDepth;
    out_bestDepthSimPtr.y = bestSampleSim;

    imageStore(out_refineDepthSimMap_d, ivec2(vx, vy), out_bestDepthSimPtr);

}