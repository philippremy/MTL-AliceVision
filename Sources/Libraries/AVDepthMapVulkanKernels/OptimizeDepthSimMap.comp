#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require

#include "definitions.comp"
#include "DeviceCameraParams.comp"
#include "Matrix.comp"
#include "Patch.comp"
#include "ROI.comp"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// The output depth similarity map
layout(rg32f, set = 0, binding = 0) uniform image2D out_optimizeDepthSimMap_d;

// The input sgm depth pixel size map
layout(rg32f, set = 0, binding = 1) uniform readonly image2D in_sgmDepthPixSizeMap_d;

// The input refine depth similarity map
layout(rg32f, set = 0, binding = 2) uniform readonly image2D in_refineDepthSimMap_d;

// The input variance image
layout(set = 0, binding = 3) uniform sampler2D imgVariance_tex;

// The input depth image
layout(set = 0, binding = 4) uniform sampler2D depth_tex;

// Device Camera Params Array
layout(set = 0, binding = 5, scalar) uniform DeviceCameraParamsConstant {
    DeviceCameraParams cameraParams[ALICEVISION_DEVICE_MAX_CONSTANT_CAMERA_PARAM_SETS];
} constantCameraParametersArray_d;

// The shader arguments
layout(push_constant, scalar) uniform PushConstants {
    int rcDeviceCameraParamsId;
    int iter;
    ROI roi;
} pushConstants;

/**
 * @return (smoothStep, energy)
 */
vec2 getCellSmoothStepEnergy(const DeviceCameraParams rcDeviceCamParams,
    const sampler2D in_depth_tex,
    const vec2 cell0,
    const vec2 offsetRoi)
{
    vec2 outp = vec2(0.0f, 180.0f);

    // get pixel depth from the depth texture
    // note: we do not use 0.5f offset because in_depth_tex use nearest neighbor interpolation
    const float d0 = texture(in_depth_tex, vec2(cell0.x, cell0.y)).x;

    // early exit: depth is <= 0
    if(d0 <= 0.0f)
        return outp;

    // consider the neighbor pixels
    const vec2 cellL = cell0 + vec2( 0.f, -1.f); // Left
    const vec2 cellR = cell0 + vec2( 0.f,  1.f); // Right
    const vec2 cellU = cell0 + vec2(-1.f,  0.f); // Up
    const vec2 cellB = cell0 + vec2( 1.f,  0.f); // Bottom

    // get associated depths from depth texture
    // note: we do not use 0.5f offset because in_depth_tex use nearest neighbor interpolation
    const float dL = texture(in_depth_tex, vec2(cellL.x, cellL.y)).x;
    const float dR = texture(in_depth_tex, vec2(cellR.x, cellR.y)).x;
    const float dU = texture(in_depth_tex, vec2(cellU.x, cellU.y)).x;
    const float dB = texture(in_depth_tex, vec2(cellB.x, cellB.y)).x;

    // get associated 3D points
    const vec3 p0 = get3DPointForPixelAndDepthFromRC(rcDeviceCamParams, cell0 + offsetRoi, d0);
    const vec3 pL = get3DPointForPixelAndDepthFromRC(rcDeviceCamParams, cellL + offsetRoi, dL);
    const vec3 pR = get3DPointForPixelAndDepthFromRC(rcDeviceCamParams, cellR + offsetRoi, dR);
    const vec3 pU = get3DPointForPixelAndDepthFromRC(rcDeviceCamParams, cellU + offsetRoi, dU);
    const vec3 pB = get3DPointForPixelAndDepthFromRC(rcDeviceCamParams, cellB + offsetRoi, dB);

    // compute the average point based on neighbors (cg)
    vec3 cg = vec3(0.0f, 0.0f, 0.0f);
    float n = 0.0f;

    if(dL > 0.0f) { cg = cg + pL; n++; }
    if(dR > 0.0f) { cg = cg + pR; n++; }
    if(dU > 0.0f) { cg = cg + pU; n++; }
    if(dB > 0.0f) { cg = cg + pB; n++; }

    // if we have at least one valid depth
    if(n > 1.0f)
    {
        cg = cg / n; // average of x, y, depth
        vec3 vcn = rcDeviceCamParams.C - p0;
        vcn = normalize(vcn);
        // pS: projection of cg on the line from p0 to camera
        const vec3 pS = closestPointToLine3D(cg, p0, vcn);
        // keep the depth difference between pS and p0 as the smoothing step
        outp.x = length(rcDeviceCamParams.C - pS) - d0;
    }

    float e = 0.0f;
    n = 0.0f;

    if(dL > 0.0f && dR > 0.0f)
    {
        // large angle between neighbors == flat area => low energy
        // small angle between neighbors == non-flat area => high energy
        e = max(e, (180.0f - angleBetwABandAC(p0, pL, pR)));
        n++;
    }
    if(dU > 0.0f && dB > 0.0f)
    {
        e = max(e, (180.0f - angleBetwABandAC(p0, pU, pB)));
        n++;
    }
    // the higher the energy, the less flat the area
    if(n > 0.0f)
        outp.y = e;

    return outp;
}

void main() {

    uint roiX = gl_GlobalInvocationID.x;
    uint roiY = gl_GlobalInvocationID.y;

    if(roiX >= ROI_width(pushConstants.roi) || roiY >= ROI_height(pushConstants.roi))
        return;

    // R camera parameters
    const DeviceCameraParams rcDeviceCamParams = constantCameraParametersArray_d.cameraParams[pushConstants.rcDeviceCameraParamsId];

    // SGM upscale (rough) depth/pixSize
    const vec2 sgmDepthPixSize = imageLoad(in_sgmDepthPixSizeMap_d, ivec2(roiX, roiY)).xy;
    const float sgmDepth = sgmDepthPixSize.x;
    const float sgmPixSize = sgmDepthPixSize.y;

    // refined and fused (fine) depth/sim
    const vec2 refineDepthSim = imageLoad(in_refineDepthSimMap_d, ivec2(roiX, roiY)).xy;
    const float refineDepth = refineDepthSim.x;
    const float refineSim = refineDepthSim.y;

    // output optimized depth/sim
    vec4 out_optDepthSimPtr = imageLoad(out_optimizeDepthSimMap_d, ivec2(roiX, roiY));
    vec2 out_optDepthSim = (pushConstants.iter == 0) ? vec2(sgmDepth, refineSim) : out_optDepthSimPtr.xy;
    const float depthOpt = out_optDepthSim.x;

    if (depthOpt > 0.0f)
    {

        const vec2 depthSmoothStepEnergy = getCellSmoothStepEnergy(rcDeviceCamParams, depth_tex, vec2(float(roiX), float(roiY)), vec2(float(pushConstants.roi.x.begin), float(pushConstants.roi.y.begin))); // (smoothStep, energy)
        float stepToSmoothDepth = depthSmoothStepEnergy.x;
        stepToSmoothDepth = copysignf(min(abs(stepToSmoothDepth), sgmPixSize / 10.0f), stepToSmoothDepth);
        const float depthEnergy = depthSmoothStepEnergy.y; // max angle with neighbors
        float stepToFineDM = refineDepth - depthOpt; // distance to refined/noisy input depth map
        stepToFineDM = copysignf(min(abs(stepToFineDM), sgmPixSize / 10.0f), stepToFineDM);

        const float stepToRoughDM = sgmDepth - depthOpt; // distance to smooth/robust input depth map
        const float imgColorVariance = texture(imgVariance_tex, vec2(float(roiX), float(roiY))).x; // do not use 0.5f offset because imgVariance_tex use nearest neighbor interpolation
        const float colorVarianceThresholdForSmoothing = 20.0f;
        const float angleThresholdForSmoothing = 30.0f; // 30

        // https://www.desmos.com/calculator/kob9lxs9qf
        const float weightedColorVariance = sigmoid2(5.0f, angleThresholdForSmoothing, 40.0f, colorVarianceThresholdForSmoothing, imgColorVariance);

        // https://www.desmos.com/calculator/jwhpjq6ppj
        const float fineSimWeight = sigmoid(0.0f, 1.0f, 0.7f, -0.7f, refineSim);

        // if geometry variation is bigger than color variation => the fineDM is considered noisy

        // if depthEnergy > weightedColorVariance   => energyLowerThanVarianceWeight=0 => smooth
        // else:                                    => energyLowerThanVarianceWeight=1 => use fineDM
        // weightedColorVariance max value is 30, so if depthEnergy > 30 (which means depthAngle < 150ï¿½) energyLowerThanVarianceWeight will be 0
        // https://www.desmos.com/calculator/jzbweilb85
        const float energyLowerThanVarianceWeight = sigmoid(0.0f, 1.0f, 30.0f, weightedColorVariance, depthEnergy); // TODO: 30 => 60

        // https://www.desmos.com/calculator/ilsk7pthvz
        const float closeToRoughWeight = 1.0f - sigmoid(0.0f, 1.0f, 10.0f, 17.0f, abs(stepToRoughDM / sgmPixSize)); // TODO: 10 => 30

        // f(z) = c1 * s1(z_rought - z)^2 + c2 * s2(z-z_fused)^2 + coeff3 * s3*(z-z_smooth)^2

        const float depthOptStep = closeToRoughWeight * stepToRoughDM + // distance to smooth/robust input depth map
            (1.0f - closeToRoughWeight) * (energyLowerThanVarianceWeight * fineSimWeight * stepToFineDM + // distance to refined/noisy
            (1.0f - energyLowerThanVarianceWeight) * stepToSmoothDepth); // max angle in current depthMap

        out_optDepthSim.x = depthOpt + depthOptStep;

        out_optDepthSim.y = (1.0f - closeToRoughWeight) * (energyLowerThanVarianceWeight * fineSimWeight * refineSim + (1.0f - energyLowerThanVarianceWeight) * (depthEnergy / 20.0f));
    }

    out_optDepthSimPtr.xy = out_optDepthSim;
    imageStore(out_optimizeDepthSimMap_d, ivec2(roiX, roiY), out_optDepthSimPtr);

}