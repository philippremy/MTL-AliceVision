#ifndef COLOR
#define COLOR

/**
 * @brief Euclidean distance (float4, XYZ ignore W)
 * @param[in] x1 the first pixel color
 * @param[in] x2 the second pixel color
 * @return distance
 */
float euclideanDist3(const vec4 x1, const vec4 x2)
{
    // return sqrtf((x1.x - x2.x) * (x1.x - x2.x) + (x1.y - x2.y) * (x1.y - x2.y) + (x1.z - x2.z) * (x1.z - x2.z));
    return length(vec3(x1.x - x2.x, x1.y - x2.y, x1.z - x2.z));
}

/**
 * @brief Adaptive support-weight approach for correspondence search
 *
 * @note "Adaptive Support-Weight Approach for Correspondence Search", Kuk-Jin Yoon, In So Kweon
 * @see http://koasas.kaist.ac.kr/bitstream/10203/21048/1/000235253300014.pdf
 *
 * @param[in] dx x-axis distance between the two pixels
 * @param[in] dy y-axis distance between the two pixels
 * @param[in] c1 the first patch pixel color (Lab 0..255)
 * @param[in] c2 the second patch pixel color (Lab 0..255)
 * @param[in] invGammaC the inverted strength of grouping by color similarity (gammaC: 5.5 / 105.5)
 * @param[in] invGammaP the inverted strength of grouping by proximity (gammaP: 8 / 4)
 * @return distance value
 */
float CostYKfromLab(const int dx,
    const int dy,
    const vec4 c1,
    const vec4 c2,
    const float invGammaC,
    const float invGammaP)
{
    // const float deltaC = 0; // ignore colour difference

    //// AD in RGB
    // const float deltaC =
    //    fabsf(float(c1.x) - float(c2.x)) +
    //    fabsf(float(c1.y) - float(c2.y)) +
    //    fabsf(float(c1.z) - float(c2.z));

    //// euclidean distance in RGB
    // const float deltaC = euclideanDist3(
    //    uchar4_to_float3(c1),
    //    uchar4_to_float3(c2)
    //);

    //// euclidean distance in Lab, assuming sRGB
    // const float deltaC = euclideanDist3(
    //    xyz2lab(rgb2xyz(srgb2rgb(uchar4_to_float3(c1)))),
    //    xyz2lab(rgb2xyz(srgb2rgb(uchar4_to_float3(c2))))
    //);

    // euclidean distance in Lab, assuming linear RGB
    float deltaC = euclideanDist3(c1, c2);
    // const float deltaC = fmaxf(fabs(c1.x-c2.x),fmaxf(fabs(c1.y-c2.y),fabs(c1.z-c2.z)));

    deltaC *= invGammaC;

    // spatial distance to the center of the patch (in pixels)
    // without optimization
    // float deltaP = sqrtf(float(dx * dx + dy * dy));
    float deltaP = sqrt(float(dx * dx + dy * dy));

    deltaP *= invGammaP;

    deltaC += deltaP;

    return exp(-deltaC); // Yoon & Kweon
    // return __expf(-(deltaC * deltaC / (2 * gammaC * gammaC))) * sqrtf(__expf(-(deltaP * deltaP / (2 * gammaP * gammaP)))); // DCB
    // return __expf(-((deltaC * deltaC / 2) * (invGammaC * invGammaC))) * sqrtf(__expf(-(((deltaP * deltaP / 2) * (invGammaP * invGammaP)))); // DCB
}

/**
 * @brief Adaptive support-weight approach for correspondence search
 *
 * @note "Adaptive Support-Weight Approach for Correspondence Search", Kuk-Jin Yoon, In So Kweon
 * @see http://koasas.kaist.ac.kr/bitstream/10203/21048/1/000235253300014.pdf
 *
 * @param[in] c1 the first patch pixel color (Lab 0..255)
 * @param[in] c2 the second patch pixel color (Lab 0..255)
 * @param[in] invGammaC the inverted strength of grouping by color similarity (gammaC: 5.5 / 105.5)
 * @return distance value
 */
float CostYKfromLab(const vec4 c1, const vec4 c2, const float invGammaC)
{
    // euclidean distance in Lab, assuming linear RGB
    const float deltaC = euclideanDist3(c1, c2);

    return exp(-(deltaC * invGammaC)); // Yoon & Kweon
}

#endif
